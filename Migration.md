# PostgreSQL Migration Guide for Supabase

This guide outlines the steps to successfully migrate a local Supabase database to a staging server using PostgreSQL tools.

## Prerequisites

- Access to both local and staging Supabase instances
- SSH access to the staging server
- `psql` client installed locally
- Supabase CLI installed

## Step 1: Prepare Your Migration Files

1. **Create a clean dump of your local database**:

   ```bash
   # Export roles and schema separately
   npx supabase db dump --db-url "postgresql://postgres:postgres@localhost:54322/postgres" -f roles.sql --role-only

   npx supabase db dump --db-url "postgresql://postgres:postgres@localhost:54322/postgres"  -f schema.sql

   # Export data only
   npx supabase db dump --db-url "postgresql://postgres:postgres@localhost:54322/postgres" --data-only --use-copy -f data.sql
   ```

2. **Clean up the schema and data files**:

   - **Remove `SET transaction_timeout = 0;` from the data.sql file**
   - Create a clean schema file without conflicting extensions:
     ```bash
     # Remove potentially problematic lines from schema.sql
     grep -v "CREATE TEXT SEARCH CONFIGURATION" schema.sql > schema_clean.sql
     ```

## Step 2: Prepare the Staging Server

> **⚠️ IMPORTANT**: **Ensure the migrations folder is empty on your staging server before proceeding. The presence of migrations will cause conflicts during restoration.**

1. **Reset the staging database**:

   ```bash
   # Connect to your staging server
   ssh root@your-server-ip

   # Navigate to your Supabase project
   cd /path/to/project

   # Make sure migrations folder is empty
   ls -la supabase/migrations

   # If there are migrations, move them temporarily
   mkdir -p supabase/migrations_backup
   mv supabase/migrations/* supabase/migrations_backup/

   # Reset the database with an empty migrations folder
   npx supabase db reset
   ```

2. **Set up your staging database URL**:

   ```bash
   # Set your staging database URL
   export STAGING_DB_URL="postgresql://postgres:postgres@localhost:54322/postgres"
   ```

## Step 3: Restore the Database

**Run the restore command**:

```bash
psql --single-transaction --variable ON_ERROR_STOP=1 \
  --file roles.sql \
  --file schema_clean.sql \
  --command "SET session_replication_role = 'replica';" \
  --file data.sql \
  --dbname "$STAGING_DB_URL"
```

This command:

- Uses a single transaction for atomicity
- Stops on errors
- Loads roles first
- Loads the cleaned schema
- Sets session_replication_role to 'replica' to bypass triggers and some constraints
- Loads the data

## Step 4: Reset Sequences and Verify

1. **Reset sequences to match current data**:

   ```sql
   -- Connect to your staging database
   psql "$STAGING_DB_URL"

   -- Run this SQL to reset all sequences
   DO $
   DECLARE
     r RECORD;
     max_id BIGINT;
   BEGIN
     FOR r IN
       SELECT
         tc.table_schema,
         tc.table_name,
         kc.column_name,
         pg_get_serial_sequence(tc.table_schema || '.' || tc.table_name, kc.column_name) AS seq_name
       FROM information_schema.table_constraints tc
       JOIN information_schema.key_column_usage kc
         ON kc.constraint_name = tc.constraint_name
         AND kc.table_schema = tc.table_schema
       WHERE tc.constraint_type = 'PRIMARY KEY'
         AND tc.table_schema = 'public'
         AND pg_get_serial_sequence(tc.table_schema || '.' || tc.table_name, kc.column_name) IS NOT NULL
     LOOP
       -- Get the maximum ID from the table plus 1
       EXECUTE format('SELECT COALESCE(MAX(%I), 0) + 1 FROM %I.%I',
                    r.column_name, r.table_schema, r.table_name)
       INTO max_id;

       -- Set the sequence to the next available value
       IF max_id > 1 THEN
         EXECUTE format('SELECT setval(%L, %s, false)', r.seq_name, max_id);
         RAISE NOTICE 'Reset sequence % for table %.% to %',
                     r.seq_name, r.table_schema, r.table_name, max_id;
       END IF;
     END LOOP;
   END;
   $;
   ```

2. **Verify your migration**:

   ```sql
   -- Check row counts for key tables
   SELECT 'properties' AS table_name, COUNT(*) FROM properties
   UNION ALL
   SELECT 'profiles', COUNT(*) FROM profiles
   UNION ALL
   SELECT 'property_images', COUNT(*) FROM property_images
   ORDER BY COUNT(*) DESC;
   ```

## Troubleshooting

### Identity Column Issues

If you encounter issues with identity columns during import:

```sql
-- Change identity columns to GENERATED BY DEFAULT
ALTER TABLE public.property_attribute_keys ALTER COLUMN id SET GENERATED BY DEFAULT;
ALTER TABLE public.properties ALTER COLUMN id SET GENERATED BY DEFAULT;
-- Add other tables as needed
```

### Foreign Key Constraint Issues

If you encounter foreign key constraint issues:

```sql
-- Set session_replication_role to bypass foreign key constraints
SET session_replication_role = 'replica';

-- After import, restore normal behavior
SET session_replication_role = 'origin';
```

## After Migration

1. Apply your property type classification:
   ```sql
   -- Update property types based on title and description
   UPDATE public.properties
   SET type =
       CASE
           -- Check for VILA
           WHEN title ILIKE '%ویلا%' OR description ILIKE '%ویلا%' OR
                title ILIKE '%ویلایی%' OR description ILIKE '%ویلایی%'
               THEN 'vila'
           -- Check for APARTMENT
           WHEN title ILIKE '%آپارتمان%' OR description ILIKE '%آپارتمان%' OR
                title ILIKE '%اپارتمان%' OR description ILIKE '%اپارتمان%' OR
                title ILIKE '%برج%' OR description ILIKE '%برج%' OR
                title ILIKE '%مجتمع مسکونی%' OR description ILIKE '%مجتمع مسکونی%' OR
                ((title ILIKE '%واحد%' OR description ILIKE '%واحد%') AND
                 NOT (title ILIKE '%ویلا%' OR description ILIKE '%ویلا%') AND
                 NOT (title ILIKE '%زمین%' OR description ILIKE '%زمین%'))
               THEN 'apartment'
           -- Check for LAND
           WHEN title ILIKE '%زمین%' OR description ILIKE '%زمین%' OR
                title ILIKE '%قطعه زمین%' OR description ILIKE '%قطعه زمین%' OR
                title ILIKE '%قطعه%' OR description ILIKE '%قطعه%' OR
                ((title ILIKE '%باغ%' OR description ILIKE '%باغ%') AND
                 NOT (title ILIKE '%ویلا%' OR description ILIKE '%ویلا%') AND
                 NOT (title ILIKE '%آپارتمان%' OR description ILIKE '%آپارتمان%') AND
                 NOT (title ILIKE '%اپارتمان%' OR description ILIKE '%اپارتمان%')) OR
                ((title ILIKE '%باغچه%' OR description ILIKE '%باغچه%') AND
                 NOT (title ILIKE '%ویلا%' OR description ILIKE '%ویلا%') AND
                 NOT (title ILIKE '%آپارتمان%' OR description ILIKE '%آپارتمان%') AND
                 NOT (title ILIKE '%اپارتمان%' OR description ILIKE '%اپارتمان%'))
               THEN 'land'
           ELSE NULL
       END
   WHERE type IS NULL;
   ```

## Summary of Key Lessons Learned

1. **Empty Migrations Folder**: **When restoring a database dump, ensure your migrations folder is completely empty** to avoid conflicts between the schema in your dump and the migrations.

2. **Remove Transaction Timeout**: Always **remove `SET transaction_timeout = 0;`** from the generated data.sql file as it can cause issues during import.

3. **Use Session Replication Role**: Setting `session_replication_role = 'replica'` is crucial for bypassing triggers and some constraints during data import.

4. **Single Transaction**: Using `--single-transaction` ensures that either all data is imported or none, preventing partial imports that could corrupt your database.

5. **Clean Schema**: Remove problematic configurations like duplicate text search configurations from your schema file.

6. **Post-Import Sequence Reset**: Always reset sequences after import to ensure they align with the maximum IDs in your tables.

## Common Errors and Solutions

### Duplicate Key Violations

```
ERROR: duplicate key value violates unique constraint "property_attribute_keys_pkey"
DETAIL: Key (id)=(1) already exists.
```

**Solution**: Use `session_replication_role = 'replica'` and ensure identity columns are set to `GENERATED BY DEFAULT`.

### Text Search Configuration Errors

```
ERROR: duplicate key value violates unique constraint "pg_ts_config_cfgname_index"
DETAIL: Key (cfgname, cfgnamespace)=(persian, 2200) already exists.
```

**Solution**: Remove text search configuration creation from your schema file or handle it separately.

### Permission Errors

```
ERROR: permission denied for table tenants
```

**Solution**: Ensure you're connecting with a user that has sufficient privileges. For Supabase, this is typically the `postgres` user.
